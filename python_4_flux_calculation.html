<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <link rel="stylesheet" href="/New_BAI_DataAnalysis/assets/css/just-the-docs-default.css"> <link rel="stylesheet" href="/New_BAI_DataAnalysis/assets/css/just-the-docs-head-nav.css" id="jtd-head-nav-stylesheet"> <style id="jtd-nav-activation"> .site-nav > ul.nav-list:first-child > li:not(:nth-child(5)) > a, .site-nav > ul.nav-list:first-child > li > ul > li a { background-image: none; } .site-nav > ul.nav-list:not(:first-child) a, .site-nav li.external a { background-image: none; } .site-nav > ul.nav-list:first-child > li:nth-child(5) > a { font-weight: 600; text-decoration: none; }.site-nav > ul.nav-list:first-child > li:nth-child(5) > button svg { transform: rotate(-90deg); }.site-nav > ul.nav-list:first-child > li.nav-list-item:nth-child(5) > ul.nav-list { display: block; } </style> <script src="/New_BAI_DataAnalysis/assets/js/vendor/lunr.min.js"></script> <script src="/New_BAI_DataAnalysis/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>FLUX CALCULATION | Data Analysis for Ecologist</title> <meta name="generator" content="Jekyll v3.10.0" /> <meta property="og:title" content="FLUX CALCULATION" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="A tutorial for starters learning how to use python to munipulate climate data!" /> <meta property="og:description" content="A tutorial for starters learning how to use python to munipulate climate data!" /> <link rel="canonical" href="https://ericluoyuu.github.io/New_BAI_DataAnalysis/python_4_flux_calculation.html" /> <meta property="og:url" content="https://ericluoyuu.github.io/New_BAI_DataAnalysis/python_4_flux_calculation.html" /> <meta property="og:site_name" content="Data Analysis for Ecologist" /> <meta property="og:type" content="website" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="FLUX CALCULATION" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"WebPage","description":"A tutorial for starters learning how to use python to munipulate climate data!","headline":"FLUX CALCULATION","url":"https://ericluoyuu.github.io/New_BAI_DataAnalysis/python_4_flux_calculation.html"}</script> <!-- End Jekyll SEO tag --> </head> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']], displayMath: [ ['$$', '$$'] ], processEscapes: true, processEnvironments: true } }); </script> <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"> </script> <body> <a class="skip-to-main" href="#main-content">Skip to main content</a> <svg xmlns="http://www.w3.org/2000/svg" class="d-none"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <!-- Feather. MIT License: https://github.com/feathericons/feather/blob/master/LICENSE --> <symbol id="svg-external-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"> <title id="svg-external-link-title">(external link)</title> <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <!-- Bootstrap Icons. MIT License: https://github.com/twbs/icons/blob/main/LICENSE.md --> <symbol id="svg-copy" viewBox="0 0 16 16"> <title>Copy</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard" viewBox="0 0 16 16"> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/> <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/> </svg> </symbol> <symbol id="svg-copied" viewBox="0 0 16 16"> <title>Copied</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard-check-fill" viewBox="0 0 16 16"> <path d="M6.5 0A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3Zm3 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3Z"/> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1A2.5 2.5 0 0 1 9.5 5h-3A2.5 2.5 0 0 1 4 2.5v-1Zm6.854 7.354-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 0 1 .708-.708L7.5 10.793l2.646-2.647a.5.5 0 0 1 .708.708Z"/> </svg> </symbol> </svg> <div class="side-bar"> <div class="site-header" role="banner"> <a href="/New_BAI_DataAnalysis/" class="site-title lh-tight"> Data Analysis for Ecologist </a> <button id="menu-button" class="site-button btn-reset" aria-label="Toggle menu" aria-pressed="false"> <svg viewBox="0 0 24 24" class="icon" aria-hidden="true"><use xlink:href="#svg-menu"></use></svg> </button> </div> <nav aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item"><a href="/New_BAI_DataAnalysis/" class="nav-list-link">Home</a></li><li class="nav-list-item"><a href="/New_BAI_DataAnalysis/python_0_installation.html" class="nav-list-link">0. INSTALLATION</a></li><li class="nav-list-item"><a href="/New_BAI_DataAnalysis/python_1_basics.html" class="nav-list-link">1. BASICS OF PYTHON</a></li><li class="nav-list-item"><a href="/New_BAI_DataAnalysis/python_2_data_visualization.html" class="nav-list-link">2. DATA HANDLING AND VISUALIZATION</a></li><li class="nav-list-item"><a href="/New_BAI_DataAnalysis/python_4_flux_calculation.html" class="nav-list-link">3. FLUX CALCULATION</a></li><li class="nav-list-item"><a href="/New_BAI_DataAnalysis/python_3_interpolation_gapfilling.html" class="nav-list-link">3. INTERPOLATION AND GAP FILLING</a></li><li class="nav-list-item"><a href="/New_BAI_DataAnalysis/python_4_extreme_detection.html" class="nav-list-link">4. EXTREME VALUE DETECTION</a></li></ul> </nav> <footer class="site-footer"> This site uses <a href="https://github.com/just-the-docs/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll. </footer> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search" role="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search Data Analysis for Ecologist" aria-label="Search Data Analysis for Ecologist" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> </div> <div class="main-content-wrap"> <div id="main-content" class="main-content"> <main> <h1 id="03-fluxes-calculation"> <a href="#03-fluxes-calculation" class="anchor-heading" aria-labelledby="03-fluxes-calculation"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 03. <strong>Fluxes Calculation</strong> </h1> <p>In this tutorial, we’re going to analyze the data you collected on your field trip to the Lüner forest! Your instruments measured raw gas concentrations, but as ecologists, we need to turn that into gas fluxes. Why? Because fluxes represent a rate—the speed at which gases are being exchanged. With CO₂ fluxes, we can estimate crucial metrics like ecosystem respiration (RECO) and net ecosystem exchange (NEE). With fluxes of a potent greenhouse gas like Nitrous Oxide (N₂O), we can understand a key part of the nitrogen cycle. This guide will walk you through the entire process: from cleaning the raw concentration data, to calculating meaningful fluxes, and finally to comparing the results between different land cover types.</p> <blockquote> <p><strong>Notice:</strong></p> <p>In all following sections I will insert some code snippets. You are very much encouraged to copy and paste them with the button on the top right and run them in your IDE (e.g. Spyder, vscode).</p> <h3 id="table-of-contents"> <a href="#table-of-contents" class="anchor-heading" aria-labelledby="table-of-contents"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Table of Contents </h3> <ol> <li><a href="#1-Loading-and-Exploring-Raw-Data">Read in and Merge Data Files</a></li> <li><a href="#2-Loading-and-Exploring-Raw-Data">Loading and Exploring Raw Data</a></li> <li><a href="#3-Filtering-and-Cleaning">Filtering and Cleaning</a></li> <li><a href="#4-Understanding-the-Data-Pattern">Understanding the Data Pattern</a></li> <li><a href="#5-Calculating-Flux-for-a-Single-Plot">Calculating Flux for a Single Plot</a></li> <li><a href="#6-Automating-Calculations-for-all-plots">Automating Calculations for all plots</a></li> <li><a href="#7-Comparing-Results">Comparing Results</a></li> </ol> </blockquote> <h2 id="1read-in-and-merge-data-files"> <a href="#1read-in-and-merge-data-files" class="anchor-heading" aria-labelledby="1read-in-and-merge-data-files"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 1.Read in and Merge Data Files </h2> <p>Different from the simple CSV files we might have worked with before, the raw data from the gas analyzer is more complex. When you open the file, you’ll see it contains two parts: A metadata header: This block at the top contains useful information about the measurement (like timezone, device model, etc.), but we don’t need it for our flux calculations. The data block: This is the core data we need, with columns for date, time, and gas concentrations. Our first challenge is to programmatically read only the data block and ignore the metadata. <img src="/New_BAI_DataAnalysis/assets/images/python/5/Metadata.png" alt="alt text" /></p> <p>To do this, we’ll need the pandas library for creating our DataFrame and the io library, we need to import them.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="kn">import</span> <span class="nn">io</span>
</code></pre></div></div> <p>Our strategy will be to read the file line-by-line, find the start of the data, and then pass only those lines to pandas.</p> <h3 id="11-reading-and-parsing-the-file"> <a href="#11-reading-and-parsing-the-file" class="anchor-heading" aria-labelledby="11-reading-and-parsing-the-file"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 1.1 Reading and Parsing the File </h3> <p>First, we read the entire file into a single string, and then split that string into a list of individual lines. This gives us the flexibility to find our data “landmarks.”</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Read in raw data as a string
</span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"./BAI_StudyProject_LuentenerWald/raw_data/TG20-01072-2025-08-15T110000.data.txt"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">file_content</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>

<span class="c1"># Split the string into a list of lines. 
# '\n' is the special character for a newline.
</span><span class="n">lines</span> <span class="o">=</span> <span class="n">file_content</span><span class="p">.</span><span class="n">strip</span><span class="p">().</span><span class="n">split</span><span class="p">(</span><span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">)</span>
</code></pre></div></div> <p>Next, we need to find the exact line that contains our column headers. Looking at the file, we know this line always starts with the word DATAH. We can write a short command to find the index of that line.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># This code searches through our list 'lines' and gets the index of the first line that starts with 'DATAH'
</span><span class="n">header_index</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="k">if</span> <span class="n">line</span><span class="p">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">'DATAH'</span><span class="p">))</span>

<span class="c1"># The actual data starts 2 lines after the header line (to skip the "DATAU" units line)
</span><span class="n">data_start_index</span> <span class="o">=</span> <span class="n">header_index</span> <span class="o">+</span> <span class="mi">2</span>

<span class="c1"># Now we can grab the headers themselves from that line. The values are separated by tabs ('\t').
</span><span class="n">headers</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="n">header_index</span><span class="p">].</span><span class="n">split</span><span class="p">(</span><span class="s">'</span><span class="se">\t</span><span class="s">'</span><span class="p">)</span>
</code></pre></div></div> <h3 id="12-using-iostringio-to-read-our-cleaned-data"> <a href="#12-using-iostringio-to-read-our-cleaned-data" class="anchor-heading" aria-labelledby="12-using-iostringio-to-read-our-cleaned-data"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 1.2 Using io.StringIO to Read Our Cleaned Data </h3> <p>The pd.read_csv() function is built to read from a file. We don’t have a clean file; we have a list of Python strings (lines) that we’ve already processed. So, how do we make pandas read from our list? We use io.StringIO to trick pandas. It takes our cleaned-up data lines and presents them to pandas as if they were a file stored in the computer’s memory. Info: The Python io module helps us manage data streams. io.StringIO specifically allows us to treat a regular text string as a file. This is incredibly useful when you need to pass text data to a function that expects a file, just like we’re doing with pd.read_csv().</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Join our data lines back into a single string, separated by newlines
</span><span class="n">data_string</span> <span class="o">=</span> <span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="n">data_start_index</span><span class="p">:])</span>
<span class="c1"># Read the data string into a DataFrame
</span><span class="n">df_raw</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">read_csv</span><span class="p">(</span>
    <span class="n">io</span><span class="p">.</span><span class="n">StringIO</span><span class="p">(</span><span class="n">data_string</span><span class="p">),</span>  <span class="c1"># Treat our string as a file
</span>    <span class="n">sep</span><span class="o">=</span><span class="s">'</span><span class="se">\t</span><span class="s">'</span><span class="p">,</span>                  <span class="c1"># Tell pandas the data is separated by tabs
</span>    <span class="n">header</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>               <span class="c1"># We are providing the headers ourselves, so there isn't one in the data
</span>    <span class="n">names</span><span class="o">=</span><span class="n">headers</span><span class="p">,</span>             <span class="c1"># Use the 'headers' list we extracted earlier
</span>    <span class="n">na_values</span><span class="o">=</span><span class="s">'nan'</span>            <span class="c1"># Recognize 'nan' strings as missing values
</span><span class="p">)</span>
</code></pre></div></div> <h3 id="13-final-data-formatting"> <a href="#13-final-data-formatting" class="anchor-heading" aria-labelledby="13-final-data-formatting"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 1.3 Final Data Formatting </h3> <p>The last step is to tidy up the DataFrame. We will: Remove the useless DATAH column. Combine the separate DATE and TIME columns into a single Timestamp object. This is crucial for time-series analysis. Set this new Timestamp as the DataFrame’s index, which makes plotting and selecting data by time much easier.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Drop the first column which is just the 'DATAH' label
</span><span class="k">if</span> <span class="s">'DATAH'</span> <span class="ow">in</span> <span class="n">df_raw</span><span class="p">.</span><span class="n">columns</span><span class="p">:</span>
    <span class="n">df_raw</span> <span class="o">=</span> <span class="n">df_raw</span><span class="p">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s">'DATAH'</span><span class="p">])</span>

<span class="c1"># Combine 'DATE' and 'TIME' into a proper Timestamp and set it as the index
</span><span class="k">if</span> <span class="s">'DATE'</span> <span class="ow">in</span> <span class="n">df_raw</span><span class="p">.</span><span class="n">columns</span> <span class="ow">and</span> <span class="s">'TIME'</span> <span class="ow">in</span> <span class="n">df_raw</span><span class="p">.</span><span class="n">columns</span><span class="p">:</span>
    <span class="n">df_raw</span><span class="p">[</span><span class="s">'Timestamp'</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">df_raw</span><span class="p">[</span><span class="s">'DATE'</span><span class="p">]</span> <span class="o">+</span> <span class="s">' '</span> <span class="o">+</span> <span class="n">df_raw</span><span class="p">[</span><span class="s">'TIME'</span><span class="p">])</span>
    <span class="n">df_raw</span> <span class="o">=</span> <span class="n">df_raw</span><span class="p">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s">'DATE'</span><span class="p">,</span> <span class="s">'TIME'</span><span class="p">])</span>
    <span class="n">df_raw</span> <span class="o">=</span> <span class="n">df_raw</span><span class="p">.</span><span class="n">set_index</span><span class="p">(</span><span class="s">'Timestamp'</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">"Data loaded and formatted successfully!"</span><span class="p">)</span>
<span class="n">df_raw</span><span class="p">.</span><span class="n">head</span><span class="p">()</span>
</code></pre></div></div> <p>Great! Now, we have successfully read in and formatted our raw data. However, think about our field campaigns. We went out several times and generate a new data file for each trip. If we wanted to analyze all of them, we would have to copy and paste our loading code multiple times. To avoid repetition and make our code cleaner and more reliable, it’s a best practice to wrap a reusable process into a function. Let’s turn our loading and cleaning steps into a function called load_raw_data.</p> <blockquote> <p>Your Task: Try to write this function yourself!</p> <p>Tip: The function will need to accept one argument: the filepath of the file you want to open.</p> </blockquote> <details><summary>Solution!</summary> Note: how it's the exact same logic as before, just defined within a def block. ```python def load_raw_data(filepath: str) -&gt; pd.DataFrame: """ Loads raw data from a text file, remove metadata, and returns a DataFrame. Parameters: - filepath (str): The path to the input data file. Returns: - pd.DataFrame: A cleaned DataFrame with a DatetimeIndex. """ with open(filepath) as f: file_content = f.read() lines = file_content.strip().split('\n') header_index = next(i for i, line in enumerate(lines) if line.startswith('DATAH')) data_start_index = header_index + 2 headers = lines[header_index].split('\t') df_raw = pd.read_csv( io.StringIO('\n'.join(lines[data_start_index:])), sep='\t', header=None, names=headers, na_values='nan' ) if 'DATAH' in df_raw.columns: df_raw = df_raw.drop(columns=['DATAH']) if 'DATE' in df_raw.columns and 'TIME' in df_raw.columns: df_raw['Timestamp'] = pd.to_datetime(df_raw['DATE'] + ' ' + df_raw['TIME']) df_raw = df_raw.drop(columns=['DATE', 'TIME']) df_raw = df_raw.set_index('Timestamp') print("Raw data loaded and cleaned successfully.") return df_raw ``` </details> <p>Now that we have our powerful load_raw_data function, we can easily handle data from multiple field trips. Instead of copying code, we can simply call our function in a loop. First, we create a list of all the file paths we want to load. Then, we can loop through this list, call our function for each path, and store the resulting DataFrames in a new list.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># First, let's list all the files we want to load.
# Make sure the file paths are complete and correct.
</span><span class="n">base_path</span> <span class="o">=</span> <span class="s">"./BAI_StudyProject_LuentenerWald/raw_data/"</span>
<span class="n">file_names</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s">'TG20-01072-2025-08-15T110000.data.txt'</span><span class="p">,</span> 
    <span class="s">'TG20-01072-2025-08-16T110000.data.txt'</span> <span class="c1"># A hypothetical second file
</span><span class="p">]</span>

<span class="c1"># Create the full file paths
</span><span class="n">full_file_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">base_path</span> <span class="o">+</span> <span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">file_names</span><span class="p">]</span>

<span class="c1"># Create an empty list to hold the loaded DataFrames
</span><span class="n">raw_data_list</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># Loop through each path, load the data, and append it to our list
</span><span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">full_file_paths</span><span class="p">:</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">load_raw_data</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="n">raw_data_list</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="se">\n</span><span class="s">Successfully loaded </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">raw_data_list</span><span class="p">)</span><span class="si">}</span><span class="s"> data files."</span><span class="p">)</span>
</code></pre></div></div> <p>The loop above is clear and correct. However, a more concise way to write this in Python is with a list comprehension. It achieves the exact same result in a single, readable line:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">raw_data_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">load_raw_data</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">full_file_paths</span><span class="p">]</span>
</code></pre></div></div> <p>For our flux calculations to be accurate, we need more than just gas concentrations. The Ideal Gas Law, which is the basis of the calculation, requires the ambient air temperature and air pressure at the time of each measurement. We will use the same workflow as before: load each file and then combine them.</p> <blockquote> <p>Your Task: You have two Excel files containing air temperature and two files for air pressure. Create lists of the file paths for the temperature and pressure data. Load each Excel file into a pandas DataFrame. Try using a list comprehension as we learned before! <br /></p> </blockquote> <details> <summary>Click here for the solution!</summary> Reading Excel files is very straightforward with the pd.read_excel() function. The overall logic is the same as for the gas data. ```Python # We assume the base path is the same as before base_path = "./BAI_StudyProject_LuentenerWald/raw_data/" # --- Load Air Temperature Data --- file_names_Ta = [ 'air_temperature_2025-08-15.xlsx', 'air_temperature_2025-08-16.xlsx' ] full_file_paths_Ta = [base_path + name for name in file_names_Ta] ta_data_list = [pd.read_excel(path) for path in full_file_paths_Ta] print(f"Successfully loaded {len(ta_data_list)} air temperature files.") # --- Load Air Pressure Data --- file_names_Pa = [ 'air_pressure_2025-08-15.xlsx', 'air_pressure_2025-08-16.xlsx' ] full_file_paths_Pa = [base_path + name for name in file_names_Pa] pa_data_list = [pd.read_excel(path) for path in full_file_paths_Pa] print(f"Successfully loaded {len(pa_data_list)} air pressure files.") ``` </details> <h3 id="14-concatenating-and-merging-all-data"> <a href="#14-concatenating-and-merging-all-data" class="anchor-heading" aria-labelledby="14-concatenating-and-merging-all-data"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 1.4 Concatenating and Merging All Data </h3> <p>Now that we have all our data loaded, we need to combine it into one master DataFrame for analysis. This involves two steps: Concatenate: Stacking the files of the same type together (e.g., all gas files into one, all temperature files into one). Merge: Joining the different datasets (gas, temperature, and pressure) together based on their common timestamp.</p> <p><strong>Concatenating the Datasets</strong></p> <p>First, let’s use pd.concat() to combine the lists of DataFrames we created. After combining, we must format the Timestamp column and set it as the index, just as we did before.</p><pre><code class="language-Python"># --- Concatenate and Clean Gas Data ---
df_gas = pd.concat(raw_data_list) # Assumes raw_data_list is from the previous step

# --- Concatenate and Clean Temperature Data ---
df_Ta = pd.concat(ta_data_list)
df_Ta['Timestamp'] = pd.to_datetime(df_Ta['Timestamp'])
df_Ta = df_Ta.set_index('Timestamp')

# --- Concatenate and Clean Pressure Data ---
df_Pa = pd.concat(pa_data_list)
df_Pa['Timestamp'] = pd.to_datetime(df_Pa['Timestamp'])
df_Pa = df_Pa.set_index('Timestamp')

print("--- Gas DataFrame Info ---")
df_gas.info()
print("\n--- Temperature DataFrame Info ---")
df_Ta.info()
print("\n--- Pressure DataFrame Info ---")
df_Pa.info()
</code></pre><p><strong>Merging Gas and Auxiliary Data</strong></p> <p>Finally, we need to combine our df_gas, df_Ta, and df_Pa DataFrames. We want to add the temperature and pressure columns to the gas data, matching them by the nearest timestamp. The gas analyzer records data every second, while the weather station might only record every minute. A simple merge would leave many empty rows. The perfect tool for this is pd.merge_asof(). It performs a “nearest-neighbor” merge, which is ideal for combining time-series data with different frequencies.</p><pre><code class="language-Python"># First, merge the two auxiliary datasets together
df_aux = pd.merge_asof(left=df_Ta, right=df_Pa, on='Timestamp', direction='nearest')

# Now, merge the gas data with the combined auxiliary data.
# We use direction='backward' to find the most recent weather data for each gas measurement.
df = pd.merge_asof(
    left=df_gas, 
    right=df_aux, 
    on='Timestamp', 
    direction='backward'
)

print("\n--- Final Merged DataFrame ---")
display(df.head())
df.info()
</code></pre><p>Brilliant! You now have a single, clean DataFrame called df_final that contains everything you need: the high-frequency gas concentrations and the corresponding temperature and pressure for each measurement point. We are now fully prepared to move on to the flux calculation.</p> <h2 id="2loading-and-exploring-raw-data"> <a href="#2loading-and-exploring-raw-data" class="anchor-heading" aria-labelledby="2loading-and-exploring-raw-data"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 2.Loading and Exploring Raw Data </h2> <p>Step 1: Loading and Initial Exploration of Raw Data First, we need to load our data from its raw text file format into a pandas DataFrame. This file has a custom header, so we need to parse it carefully. The function below handles reading the file, skipping the metadata lines, and converting the date and time columns into a proper timestamp.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import pandas as pd
import numpy as np
import io
import matplotlib.pyplot as plt
   
def load_and_clean_data(filepath):
    """
    Loads raw data from a text file, cleans it, and returns a DataFrame.
    """
    
    with open(filepath) as f:
        file_content = f.read()

    lines = file_content.strip().split('\n')
    header_index = next(i for i, line in enumerate(lines) if line.startswith('DATAH'))
    data_start_index = header_index + 2
    headers = lines[header_index].split('\t')

    df_raw = pd.read_csv(
        io.StringIO('\n'.join(lines[data_start_index:])),
        sep='\t',
        header=None,
        names=headers,
        na_values='nan'
    )

    if 'DATAH' in df_raw.columns:
        df_raw = df_raw.drop(columns=['DATAH'])

    if 'DATE' in df_raw.columns and 'TIME' in df_raw.columns:
        df_raw['Timestamp'] = pd.to_datetime(df_raw['DATE'] + ' ' + df_raw['TIME'])
        df_raw = df_raw.drop(columns=['DATE', 'TIME'])
        df_raw = df_raw.set_index('Timestamp')
    
    print("Raw data loaded and cleaned successfully.")
    return df_raw
</code></pre></div></div> <h1 id="-load-the-data-"> <a href="#-load-the-data-" class="anchor-heading" aria-labelledby="-load-the-data-"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> — Load the data — </h1> <p>filepath = “./BAI_StudyProject_LuentenerWald/raw_data/TG20-01072-2025-08-15T110000.data.txt” df_raw = load_and_clean_data(filepath)</p> <p>print(“\nFirst 5 rows of raw data:”) print(df_raw.head())</p> <h1 id="-visualize-the-raw-data-"> <a href="#-visualize-the-raw-data-" class="anchor-heading" aria-labelledby="-visualize-the-raw-data-"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> — Visualize the raw data — </h1> <p>fig, ax = plt.subplots(layout=’constrained’, figsize=(20, 5)) ax.plot(df_raw.index, df_raw[‘N2O’], label=’N2O Concentration (ppb)’) ax.set_xlabel(‘Time’) ax.set_ylabel(‘N2O Concentration (ppb)’) ax.set_title(‘Raw N2O Concentration Over Time’) plt.show() <!-- Placeholder for image --> As you can see from the plot, the raw data is very noisy. There are several negative values and some extremely large spikes. These are physically impossible and are likely due to sensor errors or electrical interference. We cannot calculate meaningful fluxes from this data without cleaning it first. Step 2: Data Filtering and Cleaning To remove these outliers, we’ll use a simple but effective quantile filter. We’ll calculate the 10th and 90th percentiles of the N₂O concentration and discard any data points that fall outside this range. This will effectively chop off the extreme high and low noise. code Python</p> <h1 id="calculate-the-10th-and-90th-percentiles"> <a href="#calculate-the-10th-and-90th-percentiles" class="anchor-heading" aria-labelledby="calculate-the-10th-and-90th-percentiles"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Calculate the 10th and 90th percentiles </h1> <p>p_10 = df_raw.N2O.quantile(0.10) p_90 = df_raw.N2O.quantile(0.90)</p> <h1 id="apply-the-filter"> <a href="#apply-the-filter" class="anchor-heading" aria-labelledby="apply-the-filter"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Apply the filter </h1> <p>df_filtered = df_raw[(df_raw.N2O &gt;= p_10) &amp; (df_raw.N2O &lt;= p_90)]</p> <h1 id="visualize-the-filtered-data"> <a href="#visualize-the-filtered-data" class="anchor-heading" aria-labelledby="visualize-the-filtered-data"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Visualize the filtered data </h1> <p>fig, ax1 = plt.subplots(layout=’constrained’, figsize=(20, 5)) ax1.scatter(df_filtered.index, df_filtered[‘N2O’], label=’N2O Concentration (ppb)’, s=5) # s=5 makes points smaller ax1.set_xlabel(‘Time’) ax1.set_ylabel(‘N2O Concentration (ppb)’) ax1.set_title(‘Filtered N2O Concentration Over Time’) plt.show()```</p> <p><!-- Placeholder for image --></p> <p>This looks much better! The erratic noise is gone, and a clear pattern has emerged.</p> <h2 id="step-3-understanding-the-data-pattern"> <a href="#step-3-understanding-the-data-pattern" class="anchor-heading" aria-labelledby="step-3-understanding-the-data-pattern"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Step 3: Understanding the Data Pattern </h2> <p>The filtered data shows a repeating pattern which is the signature of the <strong>static chamber method</strong>:</p> <ul> <li><strong>Baseline (Ambient Air)</strong>: The long, relatively flat periods show the baseline N₂O concentration in the ambient air.</li> <li><strong>Concentration Increase (Chamber Closed)</strong>: The sections where the concentration rises steadily and linearly are the actual measurements. This occurs when the chamber is placed over the soil, trapping the gases being emitted. The rate of this increase is what we need to calculate the flux.</li> <li><strong>Sudden Drop (Chamber Opened)</strong>: The sharp vertical drops occur when a measurement is finished, and the chamber is lifted from the ground, exposing the sensor to ambient air again.</li> <li><strong>Leveling Off</strong>: If a chamber is left on the ground for too long, the gas concentration inside can build up, altering the pressure gradient between the soil and the chamber air. This can cause the rate of increase to slow down and “level off.” For this reason, it’s crucial to use the initial, linear part of the increase for our flux calculation.</li> </ul> <h2 id="step-4-calculating-flux-for-a-single-measurement"> <a href="#step-4-calculating-flux-for-a-single-measurement" class="anchor-heading" aria-labelledby="step-4-calculating-flux-for-a-single-measurement"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Step 4: Calculating Flux for a Single Measurement </h2> <p>To calculate a flux, we need to combine the gas concentration data with <strong>metadata</strong> about our measurement setup. This includes the start and end times of each chamber placement and the physical dimensions of the chamber (like collar height).</p> <p>First, let’s define our flux calculation function, which is based on the Ideal Gas Law.</p> <p>```python from scipy import stats import seaborn as sns</p> <h1 id="define-key-physical-and-experimental-constants"> <a href="#define-key-physical-and-experimental-constants" class="anchor-heading" aria-labelledby="define-key-physical-and-experimental-constants"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Define key physical and experimental constants </h1> <p>R = 8.314 # Ideal gas constant (J K⁻¹ mol⁻¹)</p> <p>def calculate_flux(slope_ppb_s, temp_k, pressure_pa, V_over_A): “”” Calculate the N2O flux in µmol m⁻² s⁻¹. “”” # Convert slope from ppb/s to ppm/s ppm_per_second = slope_ppb_s / 1000</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Calculate molar density (mol/m³) using the ideal gas law (n/V = P/RT)
molar_density = pressure_pa / (R * temp_k)

# Flux (µmol m⁻² s⁻¹) = dC/dt [ppm/s] * V/A [m] * molar_density [mol/m³] * 1e6 [µmol/mol]
flux_umol_m2_s = ppm_per_second * V_over_A * molar_density * 1e6

return flux_umol_m2_s Now, let's create a metadata DataFrame. In a real project, you would load this from a field notebook (e.g., a CSV file). This file tells us when and where each measurement took place. We also calculate the crucial Volume-to-Area (V_over_A) ratio for the chamber at each plot. code Python # --- Create Metadata --- measurement_info = {
'plot_id': [1, 2],
'land_use': ['forest', 'forest'],
'start_time': ['2025-08-15 12:04:00', '2025-08-15 12:13:00'],
'end_time': ['2025-08-15 12:09:30', '2025-08-15 12:18:30'],
'collar_height_m': [0.055, 0.061],
'chamber_height_m': [0.40, 0.40],
'chamber_radius_m': [0.2, 0.2] } metadata_df = pd.DataFrame(measurement_info)
</code></pre></div></div> <h1 id="calculate-the-volume-to-area-ratio-va"> <a href="#calculate-the-volume-to-area-ratio-va" class="anchor-heading" aria-labelledby="calculate-the-volume-to-area-ratio-va"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Calculate the volume-to-area ratio (V/A) </h1> <p>metadata_df[‘chamber_area_m2’] = np.pi * metadata_df[‘chamber_radius_m’]**2 metadata_df[‘total_height_m’] = metadata_df[‘collar_height_m’] + metadata_df[‘chamber_height_m’] metadata_df[‘chamber_volume_m3’] = metadata_df[‘total_height_m’] * metadata_df[‘chamber_area_m2’] metadata_df[‘V_over_A’] = metadata_df[‘chamber_volume_m3’] / metadata_df[‘chamber_area_m2’]</p> <p>print(“\nMetadata created successfully:”) print(metadata_df) Now, let’s isolate the data for the first plot and perform a linear regression to find the slope (the rate of N₂O increase). code Python</p> <h1 id="-select-data-for-the-first-plot-"> <a href="#-select-data-for-the-first-plot-" class="anchor-heading" aria-labelledby="-select-data-for-the-first-plot-"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> — Select data for the first plot — </h1> <p>plot_info = metadata_df.iloc[0] start_time = pd.to_datetime(plot_info[‘start_time’]) end_time = pd.to_datetime(plot_info[‘end_time’])</p> <p>measurement_data = df_filtered[(df_filtered.index &gt;= start_time) &amp; (df_filtered.index &lt; end_time)]</p> <h1 id="create-an-elapsed_seconds-column-for-the-regression"> <a href="#create-an-elapsed_seconds-column-for-the-regression" class="anchor-heading" aria-labelledby="create-an-elapsed_seconds-column-for-the-regression"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Create an ‘elapsed_seconds’ column for the regression </h1> <p>measurement_data[‘elapsed_seconds’] = (measurement_data.index - start_time).total_seconds()</p> <h1 id="-perform-linear-regression-"> <a href="#-perform-linear-regression-" class="anchor-heading" aria-labelledby="-perform-linear-regression-"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> — Perform linear regression — </h1> <p>slope, intercept, r_value, p_value, std_err = stats.linregress( x=measurement_data[‘elapsed_seconds’], y=measurement_data[‘N2O’] )</p> <p>r_squared = r_value**2</p> <h1 id="-plot-the-regression-line-"> <a href="#-plot-the-regression-line-" class="anchor-heading" aria-labelledby="-plot-the-regression-line-"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> — Plot the regression line — </h1> <p>fig, ax = plt.subplots(layout=’constrained’, figsize=(10, 5)) ax.scatter(measurement_data[‘elapsed_seconds’], measurement_data[‘N2O’], label=’N2O Data’) ax.plot(measurement_data[‘elapsed_seconds’], intercept + slope * measurement_data[‘elapsed_seconds’], ‘r’, label=’Fitted line’) ax.set_xlabel(‘Elapsed Time (s)’) ax.set_ylabel(‘N2O Concentration (ppb)’) ax.set_title(f’Linear Regression for Plot {plot_info[“plot_id”]} (R²={r_squared:.2f})’) plt.legend() plt.show()</p> <h1 id="-calculate-the-flux-"> <a href="#-calculate-the-flux-" class="anchor-heading" aria-labelledby="-calculate-the-flux-"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> — Calculate the flux — </h1> <h1 id="well-assume-a-constant-temperature-and-pressure-for-this-example"> <a href="#well-assume-a-constant-temperature-and-pressure-for-this-example" class="anchor-heading" aria-labelledby="well-assume-a-constant-temperature-and-pressure-for-this-example"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> We’ll assume a constant temperature and pressure for this example. </h1> <p>temp_k = 293.15 # 20°C in Kelvin pressure_pa = 101325 # Standard atmospheric pressure in Pascals V_over_A = plot_info[‘V_over_A’]</p> <p>flux = calculate_flux(slope, temp_k, pressure_pa, V_over_A)</p> <p>print(f”\nResults for Plot {plot_info[‘plot_id’]}:”) print(f” - Slope (ppb/s): {slope:.4f}”) print(f” - R-squared: {r_squared:.4f}”) print(f” - Calculated Flux (µmol m⁻² s⁻¹): {flux:.4f}”) The plot shows our data and the line of best fit. The R-squared value tells us how well the line fits the data (a value &gt; 0.9 is good). The slope is the crucial dC/dt (change in concentration over time) that we feed into our calculate_flux function. Step 5: Automating Flux Calculations for All Plots Now we can wrap this logic in a loop to process all the measurements defined in our metadata_df. We will also include a Quality Control (QC) step: we only accept measurements with a good linear fit (R² &gt; 0.9), a statistically significant slope (p-value &lt; 0.05), and a positive slope (since we expect emissions, not uptake). code Python</p> <h1 id="-flux-calculation-loop-"> <a href="#-flux-calculation-loop-" class="anchor-heading" aria-labelledby="-flux-calculation-loop-"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> — Flux Calculation Loop — </h1> <p>results = []</p> <p>for index, row in metadata_df.iterrows(): start_time = pd.to_datetime(row[‘start_time’]) end_time = pd.to_datetime(row[‘end_time’])</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Select the data for this specific time window
measurement_data = df_filtered[(df_filtered.index &gt;= start_time) &amp; (df_filtered.index &lt; end_time)].copy()

if len(measurement_data) &lt; 10:
    print(f"Skipping plot {row['plot_id']} due to insufficient data.")
    continue

measurement_data['elapsed_seconds'] = (measurement_data.index - start_time).total_seconds()

# Perform linear regression
slope, intercept, r_value, p_value, std_err = stats.linregress(
    x=measurement_data['elapsed_seconds'],
    y=measurement_data['N2O']
)

# --- Quality Control (QC) ---
r_squared = r_value**2
if r_squared &lt; 0.90 or p_value &gt; 0.05 or slope &lt; 0:
    flux_umol_m2_s = 0  # Set flux to 0 if QC fails
    qc_pass = False
else:
    qc_pass = True
    temp_k = 293.15
    pressure_pa = 101325
    V_over_A = row['V_over_A']
    flux_umol_m2_s = calculate_flux(slope, temp_k, pressure_pa, V_over_A)

# Store the results
results.append({
    'plot_id': row['plot_id'],
    'land_use': row['land_use'],
    'slope_ppb_s': slope,
    'r_squared': r_squared,
    'p_value': p_value,
    'qc_pass': qc_pass,
    'N2O_flux_umol_m2_s': flux_umol_m2_s
})
</code></pre></div></div> <h1 id="convert-the-results-list-to-a-final-dataframe"> <a href="#convert-the-results-list-to-a-final-dataframe" class="anchor-heading" aria-labelledby="convert-the-results-list-to-a-final-dataframe"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Convert the results list to a final DataFrame </h1> <p>flux_results_df = pd.DataFrame(results)</p> <p>print(“\nFlux calculation complete:”) print(flux_results_df) This final DataFrame contains all the information we need: the calculated flux for each plot, the quality of the regression, and whether it passed our QC checks. Step 6: Comparing Fluxes for Different Land Covers The final step is to visualize our results. We want to see if there is a difference in N₂O emissions between our different land uses. A boxplot is a perfect way to do this. Let’s expand our metadata to include a hypothetical “grassland” land use to make the comparison more interesting. code Python</p> <h1 id="-re-create-metadata-with-two-land-uses-for-comparison-"> <a href="#-re-create-metadata-with-two-land-uses-for-comparison-" class="anchor-heading" aria-labelledby="-re-create-metadata-with-two-land-uses-for-comparison-"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> — Re-create metadata with two land uses for comparison — </h1> <p>measurement_info_full = { ‘plot_id’: [1, 2, 3, 4], ‘land_use’: [‘forest’, ‘forest’, ‘grassland’, ‘grassland’], ‘start_time’: [‘2025-08-15 12:04:00’, ‘2025-08-15 12:13:00’, ‘2025-08-15 12:18:00’, ‘2025-08-15 12:23:00’ ], ‘end_time’: [‘2025-08-15 12:09:30’, ‘2025-08-15 12:18:30’, ‘2025-08-15 12:21:00’, ‘2025-08-15 12:26:00’], ‘collar_height_m’: [0.055, 0.061, 0.045, 0.049], ‘chamber_height_m’: [0.40] * 4, ‘chamber_radius_m’: [0.2] * 4 }</p> <h1 id="note-you-would-need-to-re-run-the-loop-in-step-5-with-this-new-metadata"> <a href="#note-you-would-need-to-re-run-the-loop-in-step-5-with-this-new-metadata" class="anchor-heading" aria-labelledby="note-you-would-need-to-re-run-the-loop-in-step-5-with-this-new-metadata"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> NOTE: You would need to re-run the loop in Step 5 with this new metadata </h1> <h1 id="to-generate-the-full-flux_results_df-for-this-plot"> <a href="#to-generate-the-full-flux_results_df-for-this-plot" class="anchor-heading" aria-labelledby="to-generate-the-full-flux_results_df-for-this-plot"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> to generate the full flux_results_df for this plot. </h1> <h1 id="for-this-tutorial-we-will-create-a-sample-final-dataframe"> <a href="#for-this-tutorial-we-will-create-a-sample-final-dataframe" class="anchor-heading" aria-labelledby="for-this-tutorial-we-will-create-a-sample-final-dataframe"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> For this tutorial, we will create a sample final DataFrame. </h1> <h1 id="sample-final-dataframe-replace-with-your-actual-results"> <a href="#sample-final-dataframe-replace-with-your-actual-results" class="anchor-heading" aria-labelledby="sample-final-dataframe-replace-with-your-actual-results"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Sample final DataFrame (replace with your actual results) </h1> <p>final_data = { ‘land_use’: [‘forest’, ‘forest’, ‘grassland’, ‘grassland’], ‘N2O_flux_umol_m2_s’: [0.012, 0.015, 0.025, 0.028] # Example values } flux_results_df_sample = pd.DataFrame(final_data)</p> <h1 id="-visualization-"> <a href="#-visualization-" class="anchor-heading" aria-labelledby="-visualization-"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> — Visualization — </h1> <p>plt.figure(figsize=(10, 7)) sns.boxplot(data=flux_results_df_sample, x=’land_use’, y=’N2O_flux_umol_m2_s’, palette=’viridis’) sns.stripplot(data=flux_results_df_sample, x=’land_use’, y=’N2O_flux_umol_m2_s’, color=’black’, size=8, jitter=True, alpha=0.7)</p> <p>plt.title(‘N₂O Flux by Land Use Type’, fontsize=16) plt.xlabel(‘Land Use’, fontsize=12) plt.ylabel(‘N₂O Flux (µmol m⁻² s⁻¹)’, fontsize=12) plt.grid(axis=’y’, linestyle=’–’, alpha=0.7) plt.show()</p> <p>``` <!-- Placeholder for image --></p> <p>This final visualization allows us to easily compare the distribution of fluxes from the forest and grassland plots. From this example plot, we could conclude that the grassland plots tend to have higher N₂O emissions than the forest plots.</p> </main> </div> </div> <div class="search-overlay"></div> </div> </body> </html>
