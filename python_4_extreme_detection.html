<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <link rel="stylesheet" href="/New_BAI_DateAnalysis/assets/css/just-the-docs-default.css"> <link rel="stylesheet" href="/New_BAI_DateAnalysis/assets/css/just-the-docs-head-nav.css" id="jtd-head-nav-stylesheet"> <style id="jtd-nav-activation"> .site-nav > ul.nav-list:first-child > li:not(:nth-child(6)) > a, .site-nav > ul.nav-list:first-child > li > ul > li a { background-image: none; } .site-nav > ul.nav-list:not(:first-child) a, .site-nav li.external a { background-image: none; } .site-nav > ul.nav-list:first-child > li:nth-child(6) > a { font-weight: 600; text-decoration: none; }.site-nav > ul.nav-list:first-child > li:nth-child(6) > button svg { transform: rotate(-90deg); }.site-nav > ul.nav-list:first-child > li.nav-list-item:nth-child(6) > ul.nav-list { display: block; } </style> <script src="/New_BAI_DateAnalysis/assets/js/vendor/lunr.min.js"></script> <script src="/New_BAI_DateAnalysis/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>EXTREME VALUE DETECTION | Data Analysis for Ecologist</title> <meta name="generator" content="Jekyll v3.10.0" /> <meta property="og:title" content="EXTREME VALUE DETECTION" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="A tutorial for starters learning how to use python to munipulate climate data!" /> <meta property="og:description" content="A tutorial for starters learning how to use python to munipulate climate data!" /> <link rel="canonical" href="https://ericluoyuu.github.io/New_BAI_DateAnalysis/python_4_extreme_detection.html" /> <meta property="og:url" content="https://ericluoyuu.github.io/New_BAI_DateAnalysis/python_4_extreme_detection.html" /> <meta property="og:site_name" content="Data Analysis for Ecologist" /> <meta property="og:type" content="website" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="EXTREME VALUE DETECTION" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"WebPage","description":"A tutorial for starters learning how to use python to munipulate climate data!","headline":"EXTREME VALUE DETECTION","url":"https://ericluoyuu.github.io/New_BAI_DateAnalysis/python_4_extreme_detection.html"}</script> <!-- End Jekyll SEO tag --> </head> <body> <a class="skip-to-main" href="#main-content">Skip to main content</a> <svg xmlns="http://www.w3.org/2000/svg" class="d-none"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <!-- Feather. MIT License: https://github.com/feathericons/feather/blob/master/LICENSE --> <symbol id="svg-external-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"> <title id="svg-external-link-title">(external link)</title> <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <!-- Bootstrap Icons. MIT License: https://github.com/twbs/icons/blob/main/LICENSE.md --> <symbol id="svg-copy" viewBox="0 0 16 16"> <title>Copy</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard" viewBox="0 0 16 16"> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/> <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/> </svg> </symbol> <symbol id="svg-copied" viewBox="0 0 16 16"> <title>Copied</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard-check-fill" viewBox="0 0 16 16"> <path d="M6.5 0A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3Zm3 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3Z"/> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1A2.5 2.5 0 0 1 9.5 5h-3A2.5 2.5 0 0 1 4 2.5v-1Zm6.854 7.354-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 0 1 .708-.708L7.5 10.793l2.646-2.647a.5.5 0 0 1 .708.708Z"/> </svg> </symbol> </svg> <div class="side-bar"> <div class="site-header" role="banner"> <a href="/New_BAI_DateAnalysis/" class="site-title lh-tight"> Data Analysis for Ecologist </a> <button id="menu-button" class="site-button btn-reset" aria-label="Toggle menu" aria-pressed="false"> <svg viewBox="0 0 24 24" class="icon" aria-hidden="true"><use xlink:href="#svg-menu"></use></svg> </button> </div> <nav aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item"><a href="/New_BAI_DateAnalysis/" class="nav-list-link">Home</a></li><li class="nav-list-item"><a href="/New_BAI_DateAnalysis/python_0_installation.html" class="nav-list-link">0. INSTALLATION</a></li><li class="nav-list-item"><a href="/New_BAI_DateAnalysis/python_1_basics.html" class="nav-list-link">1. BASICS OF PYTHON</a></li><li class="nav-list-item"><a href="/New_BAI_DateAnalysis/python_2_data_visualization.html" class="nav-list-link">2. DATA HANDLING AND VISUALIZATION</a></li><li class="nav-list-item"><a href="/New_BAI_DateAnalysis/python_3_interpolation_gapfilling.html" class="nav-list-link">3. INTERPOLATION AND GAP FILLING</a></li><li class="nav-list-item"><a href="/New_BAI_DateAnalysis/python_4_extreme_detection.html" class="nav-list-link">4. EXTREME VALUE DETECTION</a></li></ul> </nav> <footer class="site-footer"> This site uses <a href="https://github.com/just-the-docs/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll. </footer> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search" role="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search Data Analysis for Ecologist" aria-label="Search Data Analysis for Ecologist" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> <nav aria-label="Auxiliary" class="aux-nav"> <ul class="aux-nav-list"> <li class="aux-nav-list-item"> <a href="https://github.com/just-the-docs/just-the-docs-template" class="site-button" > Template Repository </a> </li> </ul> </nav> </div> <div class="main-content-wrap"> <div id="main-content" class="main-content"> <main> <h1 id="extreme-value-detection"> <a href="#extreme-value-detection" class="anchor-heading" aria-labelledby="extreme-value-detection"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <strong>Extreme value detection</strong> </h1> <p>In this exercise we will look at extreme values in meteorological data. First you will learn about different ways to define what is an “extreme” value (extreme relative to what?). Afterwards we will work with an example dataset and code the methods in Python to get some hands on experience.</p> <h3 id="table-of-contents"> <a href="#table-of-contents" class="anchor-heading" aria-labelledby="table-of-contents"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Table of Contents </h3> <ol> <li><a href="#1-material">Material</a></li> <li><a href="#2-background">Background</a></li> <li><a href="#3-methods-and-implementation">Methods and Implementation</a><br /> 3.1. <a href="#31-peak-over-threshold-pot">Peak Over Threshold (POT)</a><br /> 3.2. <a href="#32-block-maxima-method-bm">Block Maxima (BM)</a><br /> 3.3. <a href="#33-moving-average-method-ma">Moving Average (MA)</a></li> </ol> <h3 id="1-material"> <a href="#1-material" class="anchor-heading" aria-labelledby="1-material"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 1. Material </h3> <p>We will once again use the DWD dataset from the Diepholz station for this section. Below you can find the download again: <a href="/New_BAI_DateAnalysis/assets/data/dwd_diepholz_1996_2023.parquet">Diepholz DWD meteo data (25mb)…</a>.<br /> <a href="/assets/r_ex4/wmo-td_1500_en.pdf">Literatur</a></p> <p>We will have to do some plotting again, so it might be good for you to resample the data to daily data, just to reduce the size of the dataset a bit. By now you should know how to do it. Try to create a pandas Series with hourly air temperature data.<br /> If you are getting stuck, you can refer to the exercise before.</p> <h3 id="2-background"> <a href="#2-background" class="anchor-heading" aria-labelledby="2-background"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 2. Background </h3> <p>We will look at three different methods to determine extreme events from time series of meteorological data. The main difference between the methods is the way they define the reference, to which we compare a value to describe it as being “extreme” or not.<br /> Pause for a second and think about how you could describe what an extreme value is.</p> <p>There are several ways to think about extreme values. An extreme value can simply be the highest/lowest value in a finite set of data. Think for example about testing the highest speed that a car reaches on a test drive. Here the absolute peak value would be a reasonable value of interest.</p> <p>In meteorological time series we are often interested in a range of extreme values. In other words, we are interested in the values in the tails of the distribution of our sample data, which exceed a certain threshold. It is important to consider the distribution of our underlying dataset and the question we actually want to answer.</p> <p>Our example dataset comprises of air temperature data from 1996 to 2023. If we are interested in the extreme values with respect to this whole time period, we can simply look at the distribution of all the data, determine a threshold and see which datapoints are above the upper or below the lower threshold.</p> <p>However, we might also be interested in the months with extreme temperatures. Because our distribution includes winter and summer data, extreme temperatures in spring and autumn will probably not be considered in this approach. For these we would have to create data distributions of seasonal, monthly or even daily data to evaluate extreme events on the respective time scale. This will become more obvious when we look at the methods.</p> <details> <summary> Read More: Extreme value return periods </summary> Another approach is the evaluation of extreme values and their probabilities based on historical data. Relating these probabilities to the time series of the data produces "return periods", frequencies in which the extreme values are expected to occur. As an example, requirements for buildings often include a resistance to weather extremes with a certain return period. Making up a case, wind turbines would be built that they can withstand windspeeds with a "return level" in a "return period" of 1 in 10.000, meaning the chance that such a windspeed occurs in a year would be 0.01%. </details> <h3 id="3-methods-and-implementation"> <a href="#3-methods-and-implementation" class="anchor-heading" aria-labelledby="3-methods-and-implementation"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 3. Methods and Implementation </h3> <p>Lets now look at three different methods to analyze extreme events in our sample dataset. We will talk about the reasoning and the implementations of the methods. We will then go through each method and implement the methods into functions, which you can then use to analyze your data.</p> <p>As a little preface we need to talk about a concept we will use for all methods: Quantiles.<br /> What are quantiles?</p> <p>A quantile is a subset of the given data, that contains a certain percentage of the distribution of the data. E.g. in the following figure, everything left of the red line is in the q10 percentile, the lowest 10% of the data. Everything up to the blue line is in the q90, the quantity that comprises of 90% of the data. <img src=".\misc\2023\01\05\quantiles.png" alt="Quantiles" /> You can use the following function to visualize the quantiles of our dataset:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">visualize_quantiles</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="n">pd</span><span class="p">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">q_low</span><span class="p">:</span><span class="nb">float</span><span class="p">,</span> <span class="n">q_high</span><span class="p">:</span><span class="nb">float</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">scipy.stats</span> <span class="k">as</span> <span class="n">stats</span>
    <span class="n">x_mean</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">x_sd</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">std</span><span class="p">()</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">stats</span><span class="p">.</span><span class="n">norm</span><span class="p">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">sort_values</span><span class="p">(),</span> <span class="n">x_mean</span><span class="p">,</span> <span class="n">x_sd</span><span class="p">)</span> <span class="c1"># This function creates the y-values of the normal distribution given our data, the mean and the standard deviation
</span>    <span class="n">qh</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">q_high</span><span class="p">)</span> <span class="c1"># here we calculate the higher quantile threshold
</span>    <span class="n">ql</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">q_low</span><span class="p">)</span> <span class="c1"># here we calculate the lower quantile threshold 
</span>    <span class="n">fig</span> <span class="o">=</span> <span class="n">px</span><span class="p">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">.</span><span class="n">sort_values</span><span class="p">(),</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
    <span class="n">fig</span><span class="p">.</span><span class="n">add_trace</span><span class="p">(</span>
        <span class="n">go</span><span class="p">.</span><span class="n">Scatter</span><span class="p">(</span>
            <span class="n">x</span><span class="o">=</span><span class="p">[</span><span class="n">ql</span><span class="p">,</span> <span class="n">ql</span><span class="p">],</span>
            <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="nb">max</span><span class="p">(</span><span class="n">y</span><span class="p">)],</span>
            <span class="n">mode</span><span class="o">=</span><span class="s">"lines"</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">q_low</span><span class="o">*</span><span class="mi">100</span><span class="si">}</span><span class="s">% quantile"</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="n">fig</span><span class="p">.</span><span class="n">add_trace</span><span class="p">(</span>
        <span class="n">go</span><span class="p">.</span><span class="n">Scatter</span><span class="p">(</span>
            <span class="n">x</span><span class="o">=</span><span class="p">[</span><span class="n">qh</span><span class="p">,</span> <span class="n">qh</span><span class="p">],</span>
            <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="nb">max</span><span class="p">(</span><span class="n">y</span><span class="p">)],</span>
            <span class="n">mode</span><span class="o">=</span><span class="s">"lines"</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">q_high</span><span class="o">*</span><span class="mi">100</span><span class="si">}</span><span class="s">% quantile"</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="n">fig</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">get_quantiles</span><span class="p">(</span><span class="n">df_dwd_ta_hourly</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">)</span>
</code></pre></div></div> <p>Alright, now that we layed out the basics, lets dive into theme methods!</p> <p><img src="/New_BAI_DateAnalysis/assets/images/python/4/extreme_meme.png" alt="extreme Meme" /></p> <h4 id="31-peak-over-threshold-pot"> <a href="#31-peak-over-threshold-pot" class="anchor-heading" aria-labelledby="31-peak-over-threshold-pot"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 3.1 Peak Over Threshold (POT) </h4> <p>The first approach is the Point Over Threshold (POT) method. This is a very simple approach that looks at the whole dataset as one.<br /> We define fixed thresholds for the dataset, defining the upper and lower bounds above or below which values will be considered extreme.<br /> The boundaries are usually defined by the quantiles we provided as an argument to the function.</p> <div style="background-color: #E0E0E0; padding: 15px; border-radius: 5px; margin-bottom: 20px;"> <h3> <a href="#31-peak-over-threshold-pot" class="anchor-heading" aria-labelledby="31-peak-over-threshold-pot"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Exercise </h3> <p>Let's try and code that method ourselves. It is actually not very difficult!<br /> Define a new function called "peak_over_threshold()".<br /> It needs to take a series of data as input and the quantile we want to use for extreme detection.<br /> Then we need to do the following operations:</p> <ol> <li>Find the upper and lower thresholds for what is to be defined as extreme, based on the quantiles. To find these values you can use the handy Python function "quantiles()". Just call it on the input Series and provide the quantiles as argument as in "X.quantiles(0.95)". Remember: You want the upper <strong>and lower</strong> thresholds. Think about how you can get both.</li> <li>Find those rows in the input series which are higher and lower than the upper and lower thresholds. You can get Series of booleans by comparing a pandas Series with a value. You can try it out, just type for example "X &gt; 270" if X is your Series.</li> <li>Finally you want to create a dataframe, because of course you want to return the results of your extreme value detection. Create a dataframe with the input data and two new columns, one containing the booleans of your high extreme values and the other for the low extremes.</li> </ol> <p>A little hint: The description here is quite long but the code for this is actually quite short.</p> <details> <summary style="cursor: pointer; color: #0366d6; font-weight: bold;"> Hint if you get stuck!</summary> <div style="padding: 15px; background-color: #ffffff; border-radius: 5px; margin-top: 10px;"> <p>You can generate a Series of boolean values that indicate whether a datapoint is above or below a value with a direct comparison such as</p><pre><code>X_larger_than_280 = X &gt; 280</code></pre></div> </details> <details> <summary style="cursor: pointer; color: #0366d6; font-weight: bold;"> Solution!</summary> <div style="padding: 15px; background-color: #ffffff; border-radius: 5px; margin-top: 10px;"><pre><code>
def peak_over_threshold(X:pd.Series, prob):

    print(f'Extremes detection using peak over threshold method at: {prob} percentile')
    df = pd.DataFrame(index=X.index, data = {
        "data": X,
        "extreme_low":  X &lt; X.quantile(q=1-prob),
        "extreme_high":  X &gt; X.quantile(q=prob)
    })
    return df
      </code></pre></div> </details> </div> <h4 id="32-block-maxima-method-bm"> <a href="#32-block-maxima-method-bm" class="anchor-heading" aria-labelledby="32-block-maxima-method-bm"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 3.2. Block Maxima Method (BM) </h4> <p>The next method we are looking at is the “Block Maxima” method. As the name states, we are looking at a certain “block” of data and find the maxima based on the defined threshold of the values in this block. There are several ways we could define these reference blocks. For example we could look at every year individually and find the extreme values for these. Alternatively, we could create blocks from each week of the year across all years or for every month across all years. We could then find extremes based on the quantiles of the data for every wekk of the year and separate e.g. extreme values in spring and autumn from the overshadowing extreme values in winter and summer.</p> <p>In our example we will define the blocks as the values for each single day across all the years. The procedure is as follows:</p> <p><strong>Step 1</strong><br /> In the first line we again create a dataframe with the data, a date column and then add a new column called “DOY” with a mutation, that gives each date a value of 1 to 365. We need this “day” value to group our data across the years by it. We can get this by grabbing the “day_of_year” property from our datetime-indices in Pandas.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">df_bm</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">X</span><span class="p">.</span><span class="n">index</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span>
        <span class="s">"doy"</span><span class="p">:</span><span class="n">X</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">day_of_year</span><span class="p">,</span>
        <span class="s">"data"</span><span class="p">:</span><span class="n">X</span><span class="p">.</span><span class="n">values</span><span class="p">,</span>
    <span class="p">})</span>
</code></pre></div></div> <p><strong>Step 2</strong><br /> Next we create the column “data_14d_ma”. This is the 15 day moving average around every day. Moving average means that the “window” of data we are calculating the mean from varies.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">df_bm</span><span class="p">[</span><span class="s">"data_14d_ma"</span><span class="p">]</span> <span class="o">=</span> <span class="n">X</span><span class="p">.</span><span class="n">rolling</span><span class="p">(</span><span class="n">window</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="bp">True</span><span class="p">).</span><span class="n">mean</span><span class="p">()</span>
</code></pre></div></div> <p>Through this, we accquire a smoothing of the daily temperature values and make the underlying dataset for our daily temperature distribution more broad. The reasoning is the following:<br /> We want to create a representative dataset for daily temperature values across the years. If we use the single day for each year, we have a dataset of 18 datapoints which can easily include heavy outliers. By using a moving average of 15 days we enhance our dataset for each day by a factor of 15 to 270 datapoints, still restricted to a pretty small time window. While it does reduce the impact of individual extremely hot or cold days, it is more likely to representatively capture the state of the atmosphere around the time of interest.</p> <p><strong>Step 3</strong><br /> Now that we have the smoothed data and our doy information we can go ahead and calculate the long-term mean for every day of the year. To do so, we use the pandas “groupby” function. This allows us to sample data based on common values in a column. E.g. for the day of the year, it will grab all values where the day of the year is 1 and calculate the mean for those, then for day 2 and so on.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">long_term_means</span> <span class="o">=</span> <span class="n">df_bm</span><span class="p">.</span><span class="n">groupby</span><span class="p">(</span><span class="s">"doy"</span><span class="p">)[</span><span class="s">"data_14d_ma"</span><span class="p">].</span><span class="n">mean</span><span class="p">()</span>
</code></pre></div></div> <p>Now that we have those long term means, we can calculate the difference between every datapoint and the long-term mean that fits to its day of the year. To make it more clear, we can use the pandas “iterrows” function that allows us to loop through the rows of the dataframe. First we create a new column filled with zeros called “diff”. Then we go through the rows of the dataframe, grab that long-term mean value by its index that corresponds to the “doy” of the current row (done with long_term_means.index == df_bm.loc[row,”doy”]). Then we subtract that long-term mean from that corresponding datapoint.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">df_bm</span><span class="p">[</span><span class="s">"diff"</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df_bm</span><span class="p">))</span>
<span class="k">for</span> <span class="n">row</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">df_bm</span><span class="p">.</span><span class="n">iterrows</span><span class="p">():</span>
    <span class="n">ltm</span> <span class="o">=</span> <span class="n">long_term_means</span><span class="p">[</span><span class="n">long_term_means</span><span class="p">.</span><span class="n">index</span> <span class="o">==</span> <span class="n">df_bm</span><span class="p">.</span><span class="n">loc</span><span class="p">[</span><span class="n">row</span><span class="p">,</span><span class="s">"doy"</span><span class="p">]]</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">df_bm</span><span class="p">.</span><span class="n">loc</span><span class="p">[</span><span class="n">row</span><span class="p">,</span><span class="s">"data"</span><span class="p">]</span> <span class="o">-</span> <span class="n">ltm</span>
    <span class="n">df_bm</span><span class="p">.</span><span class="n">loc</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="s">"diff"</span><span class="p">]</span> <span class="o">=</span> <span class="n">diff</span><span class="p">.</span><span class="n">values</span>
</code></pre></div></div> <p><strong>Step 4</strong><br /> One thing is still missing: the threshold to define our datapoint as extreme! In this approach we define the thresholds for something to be extreme based on the “diff” column. We want to find those values, where the deviation from the long-term mean for that specific day of the year is larger than usual. Makes sense right? Again we can use the quantiles function to find the extremes of the differences:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">upper_thresh</span> <span class="o">=</span> <span class="n">df_bm</span><span class="p">[</span><span class="s">"diff"</span><span class="p">].</span><span class="n">quantile</span><span class="p">(</span><span class="n">prob</span><span class="p">)</span>
<span class="n">lower_thresh</span> <span class="o">=</span> <span class="n">df_bm</span><span class="p">[</span><span class="s">"diff"</span><span class="p">].</span><span class="n">quantile</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">prob</span><span class="p">)</span>
<span class="n">df_bm</span><span class="p">[</span><span class="s">"extreme_high"</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_bm</span><span class="p">[</span><span class="s">"diff"</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">upper_thresh</span><span class="p">,</span> <span class="s">"data"</span>
<span class="n">df_bm</span><span class="p">[</span><span class="s">"extreme_low"</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_bm</span><span class="p">[</span><span class="s">"diff"</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">lower_thresh</span><span class="p">,</span> <span class="s">"data"</span>
</code></pre></div></div> <p>Note: In the POT approach the quantiles where built from the whole dataset itself. Here, the quantiles are built from the array of deviations from the mean! Remember this in the exercise when you evaluate the results.</p> <div style="background-color: #E0E0E0; padding: 5px; border-radius: 2px; margin-bottom: 20px;"> <h3> <a href="#32-block-maxima-method-bm" class="anchor-heading" aria-labelledby="32-block-maxima-method-bm"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Exercise </h3> <ol> <li>Go ahead and built a function for the block maxima method. You already got all the building blocks. Put them together and add the right function definition and return statement.</li> <li>After using POT and the BM, which method do you expect to yield more extreme values per year? How do you think the extremes of the two methods are different from each other?</li> <li>To compare the outcomes of the two functions you can plot the distributions of the extreme values together. In the "visualize_quantiles" method above you already have a function given that creates a distribution. Write a new function that builds distributions of the extreme values for the different methods and creates a plot. This can well be done by first creating an empty figure object and then looping through the different extremes-dataframes, calculating the distributions for each and adding a new trace. After the loop you can call the "fig.show()" to display the figure. A starter code is given below.</li> </ol> <details> <summary style="cursor: pointer; color: #0366d6; font-weight: bold;"> Starter Code ex. 3</summary> <div style="padding: 15px; background-color: #ffffff; border-radius: 5px; margin-top: 10px;"><pre><code>
def visualize_extreme_distributions(dfs:list[pd.DataFrame], extr_high_col:str, extr_low_col:str, methods:list[str]):
    print("----")
    print("Printing extremes")
    colors = ["red", "blue", "green", "purple", "lightblue", "coral"]
    
    fig = go.Figure()
    for i,df in enumerate(dfs):
        method = methods[i]
        color = colors[i]
        #... calculate distributions and add new traces to  the figure
        # You can nicely visualize the different methods by giving them the 
        # same color but maybe differentiate low and high
        # extremes by using dashed and solid lines
        # Use the "method" variable to give the traces
        # labels (with the "name" parameter to tell them apart
        # in the legend)
      </code></pre></div> </details> <details> <summary style="cursor: pointer; color: #0366d6; font-weight: bold;"> Solution Ex. 1</summary> <div style="padding: 15px; background-color: #ffffff; border-radius: 5px; margin-top: 10px;"><pre><code>
# the full code for the block maxima method
def block_maxima(X:pd.Series, prob:float):
    df_bm = pd.DataFrame(index=X.index, data={
        "doy":X.index.day_of_year,
        "data":X.values,
        "data_14d_ma": X.rolling(window=14, min_periods=1, center=True).mean()
    })
    long_term_means = df_bm.groupby("doy")["data_14d_ma"].mean()

    df_bm["diff"] = np.zeros(len(X))
    for row, index in df_bm.iterrows():
        ltm = long_term_means[long_term_means.index == df_bm.loc[row,"doy"]]
        diff = df_bm.loc[row,"data"] - ltm
        df_bm.loc[row, "diff"] = diff.values
    
    upper_thresh = df_bm["diff"].quantile(prob)
    lower_thresh = df_bm["diff"].quantile(1-prob)
    df_bm["extreme_high"] = df_bm["diff"] &gt; upper_thresh
    df_bm["extreme_low"] = df_bm["diff"] &lt; lower_thresh
    return df_bm
      </code></pre></div> </details> <details> <summary style="cursor: pointer; color: #0366d6; font-weight: bold;"> Solution Ex. 3</summary> <div style="padding: 15px; background-color: #ffffff; border-radius: 5px; margin-top: 10px;"><pre><code>
def plot_extremes_distribution(dfs:list[pd.DataFrame], extr_high_col:str, extr_low_col:str, methods:list[str]):
    print("----")
    print("Plotting extreme distributions")
    colors = ["red", "blue", "green", "purple", "lightblue", "coral"]
    
    fig = go.Figure()
    for i,df in enumerate(dfs):
        method = methods[i]
        color = colors[i]
        
        extr_highs = df.loc[df[extr_high_col] == True, "data"]
        extr_lows = df.loc[df[extr_low_col] == True, "data"]
        y_high = stats.norm.pdf(extr_highs.sort_values(), extr_highs.mean(), extr_highs.std()) # This function creates the y-values of the normal distribution given our data, the mean and the standard deviation
        y_low = stats.norm.pdf(extr_lows.sort_values(), extr_lows.mean(), extr_lows.std()) # This function creates the y-values of the normal distribution given our data, the mean and the standard deviation
        fig.add_traces(
            go.Scatter(
                x=extr_highs.sort_values(),
                y=y_high,
                name = f"{method} extreme highs",
                mode = "lines",
                line_color = color
                )
        )
        fig.add_traces(
            go.Scatter(
                x=extr_lows.sort_values(),
                y=y_low,
                name=f" {method} extreme lows",
                mode = "lines",
                line_color = color,
                line_dash = "dash"
                )
        )
    fig.update_layout(template="simple_white") # &lt;- not neccessary, I just like it!&gt;
    fig.show()
      </code></pre></div> </details> </div><hr /> <h4 id="33-moving-average-method-ma"> <a href="#33-moving-average-method-ma" class="anchor-heading" aria-labelledby="33-moving-average-method-ma"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 3.3. Moving Average Method (MA) </h4> <p>The final method we will look at is the moving average method. As the name already states, here the extremes are detected on a more temporally constrained basis, the moving average around each datapoint. Take a look at the code block for the block-maxima method. Everything we need for the moving average method is already in there. This time, try to write the method all by yourself. It is really not hard. You just need to figure out, which data you need to subtract to get the “diff” column right. As a little hint: You don’t need the day_of_year information here anymore at all.</p><hr /> <h3 id="exercises"> <a href="#exercises" class="anchor-heading" aria-labelledby="exercises"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Exercises </h3> <ol> <li>Think about how using a smaller time reference window might affect the extreme value detection. Would you expect extreme values in this approach to be more or less frequent than in the block averaging method? Then run the detection function and save the output in a new variable.</li> <li>You have now run all three methods. How do you think does the distribution look for the moving average? Use your plotting function from before to check your hypothesis.</li> <li>Change the parameter rollmean_period of the extreme detection function with the MA method to 365 and pass that output to the <code class="language-plaintext highlighter-rouge">Plot_All_Extremes()</code> function. How do you explain the output in comparison to the other methods?</li> </ol><hr /> </main> </div> </div> <div class="search-overlay"></div> </div> </body> </html>
